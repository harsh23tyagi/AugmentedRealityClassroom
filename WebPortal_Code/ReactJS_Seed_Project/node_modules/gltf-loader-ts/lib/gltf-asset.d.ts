import { FileLoader } from './fileloader';
import { GLTFBinaryData } from './glb-decoder';
import { GlTf, GlTfId } from './gltf';
import { LoadingManager } from './loadingmanager';
/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */
export declare const GLTF_COMPONENT_TYPE_ARRAYS: {
    [index: number]: any;
};
/** Spec: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#accessor-element-size */
export declare const GLTF_ELEMENTS_PER_TYPE: {
    [index: string]: number;
};
export declare class GltfAsset {
    /** The JSON part of the asset. */
    gltf: GlTf;
    glbData: GLTFBinaryData | undefined;
    /** Helper for accessing buffer data */
    bufferData: BufferData;
    /** Helper for accessing image data */
    imageData: ImageData;
    constructor(gltf: GlTf, baseUri: string, glbData: GLTFBinaryData | undefined, manager?: LoadingManager);
    /**
     * Fetch the data for a buffer view. Pass in the `bufferView` property of an
     * `Accessor`.
     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.
     */
    bufferViewData(index: GlTfId): Promise<Uint8Array>;
    /**
     * Fetch the data associated with the accessor. Equivalent to `bufferViewData` for most accessors; special cases:
     * - `accessor.bufferView` is undefined: create a buffer initialized with zeroes.
     * - `accessor.sparse` is defined: Copy underlying buffer view and apply values from `sparse`.
     */
    accessorData(index: GlTfId): Promise<Uint8Array>;
    /** Pre-fetches all buffer and image data. Useful to avoid stalls due to lazy loading. */
    preFetchAll(): Promise<void[][]>;
}
export declare class BufferData {
    asset: GltfAsset;
    baseUri: string;
    manager: LoadingManager;
    loader: FileLoader;
    private bufferCache;
    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager);
    /**
     * Get the buffer data. Triggers a network request if this buffer resides
     * in an external .bin file and is accessed for the first time (cached afterwards).
     * when it's accessed for the first time and `preFetchAll` has not been used.
     * To avoid any delays, use `preFetchAll` to pre-fetch everything.
     * NOTE: To avoid any unnessary copies, the data is returned as a `Uint8Array` instead of an `ArrayBuffer`.
     */
    get(index: GlTfId): Promise<Uint8Array>;
    /** Pre-fetches all buffer data. */
    preFetchAll(): Promise<void[]>;
}
export declare class ImageData {
    asset: GltfAsset;
    baseUri: string;
    manager: LoadingManager;
    /** crossorigin value for file and image requests */
    crossOrigin: string;
    private imageCache;
    constructor(asset: GltfAsset, baseUri: string, manager: LoadingManager);
    /**
     * Get the image data. Triggers a network request if image is in an external file
     * and is accessed for the first time (cached afterwards). To avoid any delays,
     * use `preFetchAll` to pre-fetch everything.
     */
    get(index: GlTfId): Promise<HTMLImageElement>;
    /** Pre-fetches all image data. */
    preFetchAll(): Promise<void[]>;
}
export declare function resolveURL(url: string, path: string): string;
